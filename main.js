/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/exif/lib/exif/Buffer.js
var require_Buffer = __commonJS({
  "node_modules/exif/lib/exif/Buffer.js"() {
    Buffer.prototype.getByte = function(offset) {
      return this[offset];
    };
    Buffer.prototype.getSignedByte = function(offset) {
      return this[offset] > 127 ? this[offset] - 256 : this[offset];
    };
    Buffer.prototype.getShort = function(offset, bigEndian) {
      var shortVal = bigEndian ? (this[offset] << 8) + this[offset + 1] : (this[offset + 1] << 8) + this[offset];
      return shortVal < 0 ? shortVal + 65536 : shortVal;
    };
    Buffer.prototype.getSignedShort = function(offset, bigEndian) {
      var shortVal = bigEndian ? (this[offset] << 8) + this[offset + 1] : (this[offset + 1] << 8) + this[offset];
      return shortVal > 32767 ? shortVal - 65536 : shortVal;
    };
    Buffer.prototype.getLong = function(offset, bigEndian) {
      var longVal = bigEndian ? (((this[offset] << 8) + this[offset + 1] << 8) + this[offset + 2] << 8) + this[offset + 3] : (((this[offset + 3] << 8) + this[offset + 2] << 8) + this[offset + 1] << 8) + this[offset];
      return longVal < 0 ? longVal + 4294967296 : longVal;
    };
    Buffer.prototype.getSignedLong = function(offset, bigEndian) {
      var longVal = bigEndian ? (((this[offset] << 8) + this[offset + 1] << 8) + this[offset + 2] << 8) + this[offset + 3] : (((this[offset + 3] << 8) + this[offset + 2] << 8) + this[offset + 1] << 8) + this[offset];
      return longVal > 2147483647 ? longVal - 4294967296 : longVal;
    };
    Buffer.prototype.getString = function(offset, length) {
      var string = [];
      for (var i = offset; i < offset + length; i++) {
        string.push(String.fromCharCode(this[i]));
      }
      return string.join("");
    };
  }
});

// node_modules/exif/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/exif/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/exif/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/exif/node_modules/debug/src/debug.js"(exports, module2) {
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_ms();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports.formatArgs.call(self, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports.init === "function") {
        exports.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/exif/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/exif/node_modules/debug/src/browser.js"(exports, module2) {
    exports = module2.exports = require_debug();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/exif/lib/exif/ExifImage.js
var require_ExifImage = __commonJS({
  "node_modules/exif/lib/exif/ExifImage.js"(exports, module2) {
    "use strict";
    var assert = require("assert");
    var fs = require("fs");
    var util = require("util");
    var BufferExtender = require_Buffer();
    var debug = require_browser()("exif");
    var DEFAULT_MAX_ENTRIES = 128;
    function ExifImage2(options, callback) {
      if (!(this instanceof ExifImage2)) {
        if (typeof options === "string") {
          options = {
            image: options
          };
        }
        assert(typeof options === "object", "Invalid options object");
        var exifImage = new ExifImage2(options, function(error, data) {
          if (error) {
            return callback(error);
          }
          callback(null, data, options.image);
        });
        return exifImage;
      }
      if (typeof options === "string") {
        options = {
          image: options
        };
      } else if (options instanceof Buffer) {
        options = {
          image: options
        };
      }
      var ops = {};
      if (options) {
        for (var k in options) {
          ops[k] = options[k];
        }
      }
      this.options = ops;
      [
        "ifd0MaxEntries",
        "ifd1MaxEntries",
        "maxGpsEntries",
        "maxInteroperabilityEntries",
        "agfaMaxEntries",
        "epsonMaxEntries",
        "fujifilmMaxEntries",
        "olympusMaxEntries",
        "panasonicMaxEntries",
        "sanyoMaxEntries"
      ].forEach(function(p) {
        if (ops[p] === void 0) {
          ops[p] = DEFAULT_MAX_ENTRIES;
        }
      });
      this.exifData = {
        image: {},
        thumbnail: {},
        exif: {},
        gps: {},
        interoperability: {},
        makernote: {}
      };
      this.offsets = {};
      if (ops.tiffOffsets) {
        exifData.offsets = offsets;
      }
      debug("New ExifImage options=", options);
      if (!ops.image) {
        return;
      }
      if (typeof callback !== "function") {
        throw new Error("You have to provide a callback function.");
      }
      var self = this;
      setImmediate(function() {
        self.loadImage(ops.image, function(error, exifData2) {
          if (error) {
            return callback(error);
          }
          callback(null, exifData2, ops.image);
        });
      });
    }
    ExifImage2.ExifImage = ExifImage2;
    module2.exports = ExifImage2;
    ExifImage2.prototype.loadImage = function(image, callback) {
      assert(typeof callback === "function", "Callback must be a function");
      var self = this;
      debug("loadImage image=", image);
      if (image.constructor.name === "Buffer") {
        this.processImage("Buffer", image, callback);
        return;
      }
      if (image.constructor.name === "String") {
        fs.readFile(image, function(error, data) {
          if (error) {
            callback(new Error("Encountered the following error while trying to read given image: " + error));
            return;
          }
          self.processImage("File: " + image, data, callback);
        });
        return;
      }
      callback(new Error("Given image is neither a buffer nor a file, please provide one of these."));
    };
    ExifImage2.prototype.processImage = function(source, data, callback) {
      assert(typeof source === "string", "Source must be a string");
      assert(typeof callback === "function", "Callback must be a function");
      var offset = 0;
      if (data[offset++] != 255 || data[offset++] != 216) {
        var e = new Error("The given image is not a JPEG and thus unsupported right now.");
        e.source = source;
        e.code = "NOT_A_JPEG";
        callback(e);
        return;
      }
      this.imageType = "JPEG";
      while (offset < data.length) {
        if (data[offset++] != 255) {
          break;
        }
        if (data[offset++] == 225) {
          try {
            this.extractExifData(data, offset + 2, data.getShort(offset, true) - 2);
          } catch (error) {
            error.code = "PARSING_ERROR";
            error.source = source;
            debug("Extract exif data error source=", source, "offset=", offset, "error=", error);
            callback(error);
            return;
          }
          debug("Extract exif data success source=", source, "exifData=", this.exifData);
          callback(null, this.exifData);
          return;
        }
        offset += data.getShort(offset, true);
      }
      var e2 = new Error("No Exif segment found in the given image.");
      e2.source = source;
      e2.code = "NO_EXIF_SEGMENT";
      callback(e2);
    };
    ExifImage2.prototype.extractExifData = function(data, start, length) {
      var exifData2 = this.exifData;
      var tiffOffset = start + 6;
      var ifdOffset, numberOfEntries;
      var noPadding = this.options.noPadding !== false;
      this.offsets.tiff = tiffOffset;
      if (data.toString("utf8", start, tiffOffset) != "Exif\0\0") {
        throw new Error("The Exif data is not valid.");
      }
      if (data.getShort(tiffOffset) == 18761) {
        this.isBigEndian = false;
      } else if (data.getShort(tiffOffset) == 19789) {
        this.isBigEndian = true;
      } else {
        throw new Error("Invalid TIFF data! Expected 0x4949 or 0x4D4D at offset " + tiffOffset + " but found 0x" + data[tiffOffset].toString(16).toUpperCase() + data[tiffOffset + 1].toString(16).toUpperCase() + ".");
      }
      debug("BigEndian=", this.isBigEndian);
      if (data.getShort(tiffOffset + 2, this.isBigEndian) != 42) {
        var expected = this.isBigEndian ? "0x002A" : "0x2A00";
        throw new Error("Invalid TIFF data! Expected " + expected + " at offset " + (tiffOffset + 2) + " but found 0x" + data[tiffOffset + 2].toString(16).toUpperCase() + data[tiffOffset + 3].toString(16).toUpperCase() + ".");
      }
      ifdOffset = tiffOffset + data.getLong(tiffOffset + 4, this.isBigEndian);
      this.offsets.ifd0 = ifdOffset;
      numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);
      if (this.options.ifd0MaxEntries) {
        numberOfEntries = Math.min(numberOfEntries, this.options.ifd0MaxEntries);
      }
      debug("IFD0 ifdOffset=", ifdOffset, "numberOfEntries=", numberOfEntries);
      for (var i = 0; i < numberOfEntries; i++) {
        var exifEntry = this.extractExifEntry(data, ifdOffset + 2 + i * 12, tiffOffset, this.isBigEndian, ExifImage2.TAGS.exif);
        if (!exifEntry) {
          continue;
        }
        if (exifEntry.tagId === 59932 && noPadding) {
          continue;
        }
        exifData2.image[exifEntry.tagName] = exifEntry.value;
      }
      debug("IFD0 parsed", exifData2.image);
      var nextIfdOffset = data.getLong(ifdOffset + 2 + numberOfEntries * 12, this.isBigEndian);
      if (nextIfdOffset != 0) {
        ifdOffset = tiffOffset + nextIfdOffset;
        this.offsets.ifd1 = ifdOffset;
        numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);
        if (this.options.ifd1MaxEntries) {
          numberOfEntries = Math.min(numberOfEntries, this.options.ifd1MaxEntries);
        }
        debug("IFD1 ifdOffset=", ifdOffset, "numberOfEntries=", numberOfEntries);
        for (var i = 0; i < numberOfEntries; i++) {
          var exifEntry = this.extractExifEntry(data, ifdOffset + 2 + i * 12, tiffOffset, this.isBigEndian, ExifImage2.TAGS.exif);
          if (!exifEntry) {
            continue;
          }
          if (exifEntry.tagId === 59932 && noPadding) {
            continue;
          }
          exifData2.thumbnail[exifEntry.tagName] = exifEntry.value;
        }
        if (this.options.fixThumbnailOffset) {
          var thumbnailOffset = exifData2.thumbnail[ExifImage2.TAGS.exif[513]];
          if (thumbnailOffset) {
            debug("IFD1 fix thumbnail offset, add=", this.offsets.tiff);
            exifData2.thumbnail[ExifImage2.TAGS.exif[513]] += this.offsets.tiff;
          }
        }
        debug("IFD1 parsed", exifData2.thumbnail);
      }
      if (exifData2.image[ExifImage2.TAGS.exif[34665]]) {
        ifdOffset = tiffOffset + exifData2.image[ExifImage2.TAGS.exif[34665]];
        this.offsets.tags = ifdOffset;
        numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);
        if (this.options.maxEntries) {
          numberOfEntries = Math.min(numberOfEntries, this.options.maxEntries);
        }
        debug("EXIF IFD ifdOffset=", ifdOffset, "numberOfEntries=", numberOfEntries);
        for (var i = 0; i < numberOfEntries; i++) {
          var exifEntry = this.extractExifEntry(data, ifdOffset + 2 + i * 12, tiffOffset, this.isBigEndian, ExifImage2.TAGS.exif);
          if (!exifEntry) {
            continue;
          }
          if (exifEntry.tagId === 59932 && noPadding) {
            continue;
          }
          exifData2.exif[exifEntry.tagName] = exifEntry.value;
        }
        debug("EXIF IFD parsed", exifData2.exif);
      }
      if (exifData2.image[ExifImage2.TAGS.exif[34853]]) {
        ifdOffset = tiffOffset + exifData2.image[ExifImage2.TAGS.exif[34853]];
        this.offsets.gps = ifdOffset;
        numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);
        if (this.options.maxGpsEntries) {
          numberOfEntries = Math.min(numberOfEntries, this.options.maxGpsEntries);
        }
        debug("GPS IFD ifdOffset=", ifdOffset, "numberOfEntries=", numberOfEntries);
        for (var i = 0; i < numberOfEntries; i++) {
          var exifEntry = this.extractExifEntry(data, ifdOffset + 2 + i * 12, tiffOffset, this.isBigEndian, ExifImage2.TAGS.gps);
          if (!exifEntry) {
            continue;
          }
          if (exifEntry.tagId === 59932 && noPadding) {
            continue;
          }
          exifData2.gps[exifEntry.tagName] = exifEntry.value;
        }
        debug("GPS IFD parsed", exifData2.gps);
      }
      if (exifData2.exif[ExifImage2.TAGS.exif[40965]]) {
        ifdOffset = tiffOffset + exifData2.exif[ExifImage2.TAGS.exif[40965]];
        this.offsets.interoperability = ifdOffset;
        numberOfEntries = data.getShort(ifdOffset, this.isBigEndian);
        if (this.options.maxInteroperabilityEntries) {
          numberOfEntries = Math.min(numberOfEntries, this.options.maxInteroperabilityEntries);
        }
        debug("Interoperability IFD ifdOffset=", ifdOffset, "numberOfEntries=", numberOfEntries);
        for (var i = 0; i < numberOfEntries; i++) {
          var exifEntry = this.extractExifEntry(data, ifdOffset + 2 + i * 12, tiffOffset, this.isBigEndian, ExifImage2.TAGS.exif);
          if (!exifEntry) {
            break;
          }
          if (exifEntry.tagId === 59932 && noPadding) {
            continue;
          }
          exifData2.interoperability[exifEntry.tagName] = exifEntry.value;
        }
        debug("Interoperability IFD parsed", exifData2.gps);
      }
      if (typeof exifData2.exif[ExifImage2.TAGS.exif[37500]] != "undefined") {
        var type;
        if (exifData2.exif[ExifImage2.TAGS.exif[37500]].getString(0, 7) === "OLYMP\0" || exifData2.exif[ExifImage2.TAGS.exif[37500]].getString(0, 7) === "OLYMP\0") {
          type = "olympus";
        } else if (exifData2.exif[ExifImage2.TAGS.exif[37500]].getString(0, 7) === "AGFA \0") {
          type = "agfa";
        } else if (exifData2.exif[ExifImage2.TAGS.exif[37500]].getString(0, 8) === "EPSON\0\0") {
          type = "epson";
        } else if (exifData2.exif[ExifImage2.TAGS.exif[37500]].getString(0, 8) === "FUJIFILM") {
          type = "fujifilm";
        } else if (exifData2.exif[ExifImage2.TAGS.exif[37500]].getString(0, 9) === "Panasonic") {
          type = "panasonic";
        } else if (exifData2.exif[ExifImage2.TAGS.exif[37500]].getString(0, 5) === "SANYO") {
          type = "sanyo";
        }
        debug("Makernote IFD ifdOffset=", ifdOffset, "type=", type);
        if (type) {
          var extractMakernotes = require("./makernotes/" + type).extractMakernotes;
          exifData2.makernote = extractMakernotes.call(this, data, this.makernoteOffset, tiffOffset);
        } else {
          exifData2.makernote["error"] = "Unable to extract Makernote information as it is in an unsupported or unrecognized format.";
        }
        debug("Makernote IFD parsed", exifData2.makernote);
      }
    };
    ExifImage2.prototype.extractExifEntry = function(data, entryOffset, tiffOffset, isBigEndian, tags) {
      var entry = {
        tag: data.slice(entryOffset, entryOffset + 2),
        tagId: null,
        tagName: null,
        format: data.getShort(entryOffset + 2, isBigEndian),
        components: data.getLong(entryOffset + 4, isBigEndian),
        valueOffset: null,
        value: []
      };
      entry.tagId = entry.tag.getShort(0, isBigEndian);
      if (tags && tags[entry.tagId] && typeof tags[entry.tagId] == "function") {
        entry.tagName = tags[entry.tagId].call(this, entry);
        if (!entry.tagName) {
          return false;
        }
      } else if (tags && tags[entry.tagId]) {
        entry.tagName = tags[entry.tagId];
        if (entry.tagName === void 0) {
          return false;
        }
      } else {
        return false;
      }
      switch (entry.format) {
        case 1:
          entry.valueOffset = entry.components <= 4 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
          for (var i = 0; i < entry.components; i++)
            entry.value.push(data.getByte(entry.valueOffset + i));
          break;
        case 2:
          entry.valueOffset = entry.components <= 4 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
          entry.value = data.getString(entry.valueOffset, entry.components);
          if (entry.value[entry.value.length - 1] === "\0")
            entry.value = entry.value.substring(0, entry.value.length - 1);
          break;
        case 3:
          entry.valueOffset = entry.components <= 2 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
          for (var i = 0; i < entry.components; i++)
            entry.value.push(data.getShort(entry.valueOffset + i * 2, isBigEndian));
          break;
        case 4:
          entry.valueOffset = entry.components == 1 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
          for (var i = 0; i < entry.components; i++)
            entry.value.push(data.getLong(entry.valueOffset + i * 4, isBigEndian));
          break;
        case 5:
          entry.valueOffset = data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
          for (var i = 0; i < entry.components; i++)
            entry.value.push(data.getLong(entry.valueOffset + i * 8, isBigEndian) / data.getLong(entry.valueOffset + i * 8 + 4, isBigEndian));
          break;
        case 6:
          entry.valueOffset = entry.components <= 4 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
          for (var i = 0; i < entry.components; i++)
            entry.value.push(data.getSignedByte(entry.valueOffset + i));
          break;
        case 7:
          entry.valueOffset = entry.components <= 4 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
          entry.value.push(data.slice(entry.valueOffset, entry.valueOffset + entry.components));
          break;
        case 8:
          entry.valueOffset = entry.components <= 2 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
          for (var i = 0; i < entry.components; i++)
            entry.value.push(data.getSignedShort(entry.valueOffset + i * 2, isBigEndian));
          break;
        case 9:
          entry.valueOffset = entry.components == 1 ? entryOffset + 8 : data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
          for (var i = 0; i < entry.components; i++)
            entry.value.push(data.getSignedLong(entry.valueOffset + i * 4, isBigEndian));
          break;
        case 10:
          entry.valueOffset = data.getLong(entryOffset + 8, isBigEndian) + tiffOffset;
          for (var i = 0; i < entry.components; i++)
            entry.value.push(data.getSignedLong(entry.valueOffset + i * 8, isBigEndian) / data.getSignedLong(entry.valueOffset + i * 8 + 4, isBigEndian));
          break;
        default:
          return false;
      }
      if (entry.tagName === "MakerNote") {
        this.offsets.makernoteOffset = entry.valueOffset;
      }
      if (entry.value.length == 1) {
        entry.value = entry.value[0];
      }
      return entry;
    };
    ExifImage2.TAGS = {
      exif: {
        1: "InteropIndex",
        2: "InteropVersion",
        11: "ProcessingSoftware",
        254: "SubfileType",
        255: "OldSubfileType",
        256: "ImageWidth",
        257: "ImageHeight",
        258: "BitsPerSample",
        259: "Compression",
        262: "PhotometricInterpretation",
        263: "Thresholding",
        264: "CellWidth",
        265: "CellLength",
        266: "FillOrder",
        269: "DocumentName",
        270: "ImageDescription",
        271: "Make",
        272: "Model",
        273: "StripOffsets",
        274: "Orientation",
        277: "SamplesPerPixel",
        278: "RowsPerStrip",
        279: "StripByteCounts",
        280: "MinSampleValue",
        281: "MaxSampleValue",
        282: "XResolution",
        283: "YResolution",
        284: "PlanarConfiguration",
        285: "PageName",
        286: "XPosition",
        287: "YPosition",
        288: "FreeOffsets",
        289: "FreeByteCounts",
        290: "GrayResponseUnit",
        291: "GrayResponseCurve",
        292: "T4Options",
        293: "T6Options",
        296: "ResolutionUnit",
        297: "PageNumber",
        300: "ColorResponseUnit",
        301: "TransferFunction",
        305: "Software",
        306: "ModifyDate",
        315: "Artist",
        316: "HostComputer",
        317: "Predictor",
        318: "WhitePoint",
        319: "PrimaryChromaticities",
        320: "ColorMap",
        321: "HalftoneHints",
        322: "TileWidth",
        323: "TileLength",
        324: "TileOffsets",
        325: "TileByteCounts",
        326: "BadFaxLines",
        327: "CleanFaxData",
        328: "ConsecutiveBadFaxLines",
        330: "SubIFD",
        332: "InkSet",
        333: "InkNames",
        334: "NumberofInks",
        336: "DotRange",
        337: "TargetPrinter",
        338: "ExtraSamples",
        339: "SampleFormat",
        340: "SMinSampleValue",
        341: "SMaxSampleValue",
        342: "TransferRange",
        343: "ClipPath",
        344: "XClipPathUnits",
        345: "YClipPathUnits",
        346: "Indexed",
        347: "JPEGTables",
        351: "OPIProxy",
        400: "GlobalParametersIFD",
        401: "ProfileType",
        402: "FaxProfile",
        403: "CodingMethods",
        404: "VersionYear",
        405: "ModeNumber",
        433: "Decode",
        434: "DefaultImageColor",
        435: "T82Options",
        437: "JPEGTables",
        512: "JPEGProc",
        513: "ThumbnailOffset",
        514: "ThumbnailLength",
        515: "JPEGRestartInterval",
        517: "JPEGLosslessPredictors",
        518: "JPEGPointTransforms",
        519: "JPEGQTables",
        520: "JPEGDCTables",
        521: "JPEGACTables",
        529: "YCbCrCoefficients",
        530: "YCbCrSubSampling",
        531: "YCbCrPositioning",
        532: "ReferenceBlackWhite",
        559: "StripRowCounts",
        700: "ApplicationNotes",
        999: "USPTOMiscellaneous",
        4096: "RelatedImageFileFormat",
        4097: "RelatedImageWidth",
        4098: "RelatedImageHeight",
        18246: "Rating",
        18247: "XP_DIP_XML",
        18248: "StitchInfo",
        18249: "RatingPercent",
        32781: "ImageID",
        32931: "WangTag1",
        32932: "WangAnnotation",
        32933: "WangTag3",
        32934: "WangTag4",
        32995: "Matteing",
        32996: "DataType",
        32997: "ImageDepth",
        32998: "TileDepth",
        33405: "Model2",
        33421: "CFARepeatPatternDim",
        33422: "CFAPattern2",
        33423: "BatteryLevel",
        33424: "KodakIFD",
        33432: "Copyright",
        33434: "ExposureTime",
        33437: "FNumber",
        33445: "MDFileTag",
        33446: "MDScalePixel",
        33447: "MDColorTable",
        33448: "MDLabName",
        33449: "MDSampleInfo",
        33450: "MDPrepDate",
        33451: "MDPrepTime",
        33452: "MDFileUnits",
        33550: "PixelScale",
        33589: "AdventScale",
        33590: "AdventRevision",
        33628: "UIC1Tag",
        33629: "UIC2Tag",
        33630: "UIC3Tag",
        33631: "UIC4Tag",
        33723: "IPTC-NAA",
        33918: "IntergraphPacketData",
        33919: "IntergraphFlagRegisters",
        33920: "IntergraphMatrix",
        33921: "INGRReserved",
        33922: "ModelTiePoint",
        34016: "Site",
        34017: "ColorSequence",
        34018: "IT8Header",
        34019: "RasterPadding",
        34020: "BitsPerRunLength",
        34021: "BitsPerExtendedRunLength",
        34022: "ColorTable",
        34023: "ImageColorIndicator",
        34024: "BackgroundColorIndicator",
        34025: "ImageColorValue",
        34026: "BackgroundColorValue",
        34027: "PixelIntensityRange",
        34028: "TransparencyIndicator",
        34029: "ColorCharacterization",
        34030: "HCUsage",
        34031: "TrapIndicator",
        34032: "CMYKEquivalent",
        34118: "SEMInfo",
        34152: "AFCP_IPTC",
        34232: "PixelMagicJBIGOptions",
        34264: "ModelTransform",
        34306: "WB_GRGBLevels",
        34310: "LeafData",
        34377: "PhotoshopSettings",
        34665: "ExifOffset",
        34675: "ICC_Profile",
        34687: "TIFF_FXExtensions",
        34688: "MultiProfiles",
        34689: "SharedData",
        34690: "T88Options",
        34732: "ImageLayer",
        34735: "GeoTiffDirectory",
        34736: "GeoTiffDoubleParams",
        34737: "GeoTiffAsciiParams",
        34850: "ExposureProgram",
        34852: "SpectralSensitivity",
        34853: "GPSInfo",
        34855: "ISO",
        34856: "Opto-ElectricConvFactor",
        34857: "Interlace",
        34858: "TimeZoneOffset",
        34859: "SelfTimerMode",
        34864: "SensitivityType",
        34865: "StandardOutputSensitivity",
        34866: "RecommendedExposureIndex",
        34867: "ISOSpeed",
        34868: "ISOSpeedLatitudeyyy",
        34869: "ISOSpeedLatitudezzz",
        34908: "FaxRecvParams",
        34909: "FaxSubAddress",
        34910: "FaxRecvTime",
        34954: "LeafSubIFD",
        36864: "ExifVersion",
        36867: "DateTimeOriginal",
        36868: "CreateDate",
        37121: "ComponentsConfiguration",
        37122: "CompressedBitsPerPixel",
        37377: "ShutterSpeedValue",
        37378: "ApertureValue",
        37379: "BrightnessValue",
        37380: "ExposureCompensation",
        37381: "MaxApertureValue",
        37382: "SubjectDistance",
        37383: "MeteringMode",
        37384: "LightSource",
        37385: "Flash",
        37386: "FocalLength",
        37387: "FlashEnergy",
        37388: "SpatialFrequencyResponse",
        37389: "Noise",
        37390: "FocalPlaneXResolution",
        37391: "FocalPlaneYResolution",
        37392: "FocalPlaneResolutionUnit",
        37393: "ImageNumber",
        37394: "SecurityClassification",
        37395: "ImageHistory",
        37396: "SubjectArea",
        37397: "ExposureIndex",
        37398: "TIFF-EPStandardID",
        37399: "SensingMethod",
        37434: "CIP3DataFile",
        37435: "CIP3Sheet",
        37436: "CIP3Side",
        37439: "StoNits",
        37500: "MakerNote",
        37510: "UserComment",
        37520: "SubSecTime",
        37521: "SubSecTimeOriginal",
        37522: "SubSecTimeDigitized",
        37679: "MSDocumentText",
        37680: "MSPropertySetStorage",
        37681: "MSDocumentTextPosition",
        37724: "ImageSourceData",
        40091: "XPTitle",
        40092: "XPComment",
        40093: "XPAuthor",
        40094: "XPKeywords",
        40095: "XPSubject",
        40960: "FlashpixVersion",
        40961: "ColorSpace",
        40962: "ExifImageWidth",
        40963: "ExifImageHeight",
        40964: "RelatedSoundFile",
        40965: "InteropOffset",
        41483: "FlashEnergy",
        41484: "SpatialFrequencyResponse",
        41485: "Noise",
        41486: "FocalPlaneXResolution",
        41487: "FocalPlaneYResolution",
        41488: "FocalPlaneResolutionUnit",
        41489: "ImageNumber",
        41490: "SecurityClassification",
        41491: "ImageHistory",
        41492: "SubjectLocation",
        41493: "ExposureIndex",
        41494: "TIFF-EPStandardID",
        41495: "SensingMethod",
        41728: "FileSource",
        41729: "SceneType",
        41730: "CFAPattern",
        41985: "CustomRendered",
        41986: "ExposureMode",
        41987: "WhiteBalance",
        41988: "DigitalZoomRatio",
        41989: "FocalLengthIn35mmFormat",
        41990: "SceneCaptureType",
        41991: "GainControl",
        41992: "Contrast",
        41993: "Saturation",
        41994: "Sharpness",
        41995: "DeviceSettingDescription",
        41996: "SubjectDistanceRange",
        42016: "ImageUniqueID",
        42032: "OwnerName",
        42033: "SerialNumber",
        42034: "LensInfo",
        42035: "LensMake",
        42036: "LensModel",
        42037: "LensSerialNumber",
        42112: "GDALMetadata",
        42113: "GDALNoData",
        42240: "Gamma",
        44992: "ExpandSoftware",
        44993: "ExpandLens",
        44994: "ExpandFilm",
        44995: "ExpandFilterLens",
        44996: "ExpandScanner",
        44997: "ExpandFlashLamp",
        48129: "PixelFormat",
        48130: "Transformation",
        48131: "Uncompressed",
        48132: "ImageType",
        48256: "ImageWidth",
        48257: "ImageHeight",
        48258: "WidthResolution",
        48259: "HeightResolution",
        48320: "ImageOffset",
        48321: "ImageByteCount",
        48322: "AlphaOffset",
        48323: "AlphaByteCount",
        48324: "ImageDataDiscard",
        48325: "AlphaDataDiscard",
        50215: "OceScanjobDesc",
        50216: "OceApplicationSelector",
        50217: "OceIDNumber",
        50218: "OceImageLogic",
        50255: "Annotations",
        50341: "PrintIM",
        50560: "USPTOOriginalContentType",
        50706: "DNGVersion",
        50707: "DNGBackwardVersion",
        50708: "UniqueCameraModel",
        50709: "LocalizedCameraModel",
        50710: "CFAPlaneColor",
        50711: "CFALayout",
        50712: "LinearizationTable",
        50713: "BlackLevelRepeatDim",
        50714: "BlackLevel",
        50715: "BlackLevelDeltaH",
        50716: "BlackLevelDeltaV",
        50717: "WhiteLevel",
        50718: "DefaultScale",
        50719: "DefaultCropOrigin",
        50720: "DefaultCropSize",
        50721: "ColorMatrix1",
        50722: "ColorMatrix2",
        50723: "CameraCalibration1",
        50724: "CameraCalibration2",
        50725: "ReductionMatrix1",
        50726: "ReductionMatrix2",
        50727: "AnalogBalance",
        50728: "AsShotNeutral",
        50729: "AsShotWhiteXY",
        50730: "BaselineExposure",
        50731: "BaselineNoise",
        50732: "BaselineSharpness",
        50733: "BayerGreenSplit",
        50734: "LinearResponseLimit",
        50735: "CameraSerialNumber",
        50736: "DNGLensInfo",
        50737: "ChromaBlurRadius",
        50738: "AntiAliasStrength",
        50739: "ShadowScale",
        50740: "DNGPrivateData",
        50741: "MakerNoteSafety",
        50752: "RawImageSegmentation",
        50778: "CalibrationIlluminant1",
        50779: "CalibrationIlluminant2",
        50780: "BestQualityScale",
        50781: "RawDataUniqueID",
        50784: "AliasLayerMetadata",
        50827: "OriginalRawFileName",
        50828: "OriginalRawFileData",
        50829: "ActiveArea",
        50830: "MaskedAreas",
        50831: "AsShotICCProfile",
        50832: "AsShotPreProfileMatrix",
        50833: "CurrentICCProfile",
        50834: "CurrentPreProfileMatrix",
        50879: "ColorimetricReference",
        50898: "PanasonicTitle",
        50899: "PanasonicTitle2",
        50931: "CameraCalibrationSig",
        50932: "ProfileCalibrationSig",
        50933: "ProfileIFD",
        50934: "AsShotProfileName",
        50935: "NoiseReductionApplied",
        50936: "ProfileName",
        50937: "ProfileHueSatMapDims",
        50938: "ProfileHueSatMapData1",
        50939: "ProfileHueSatMapData2",
        50940: "ProfileToneCurve",
        50941: "ProfileEmbedPolicy",
        50942: "ProfileCopyright",
        50964: "ForwardMatrix1",
        50965: "ForwardMatrix2",
        50966: "PreviewApplicationName",
        50967: "PreviewApplicationVersion",
        50968: "PreviewSettingsName",
        50969: "PreviewSettingsDigest",
        50970: "PreviewColorSpace",
        50971: "PreviewDateTime",
        50972: "RawImageDigest",
        50973: "OriginalRawFileDigest",
        50974: "SubTileBlockSize",
        50975: "RowInterleaveFactor",
        50981: "ProfileLookTableDims",
        50982: "ProfileLookTableData",
        51008: "OpcodeList1",
        51009: "OpcodeList2",
        51022: "OpcodeList3",
        51041: "NoiseProfile",
        51043: "TimeCodes",
        51044: "FrameRate",
        51058: "TStop",
        51081: "ReelName",
        51089: "OriginalDefaultFinalSize",
        51090: "OriginalBestQualitySize",
        51091: "OriginalDefaultCropSize",
        51105: "CameraLabel",
        51107: "ProfileHueSatMapEncoding",
        51108: "ProfileLookTableEncoding",
        51109: "BaselineExposureOffset",
        51110: "DefaultBlackRender",
        51111: "NewRawImageDigest",
        51112: "RawToPreviewGain",
        51125: "DefaultUserCrop",
        59932: "Padding",
        59933: "OffsetSchema",
        65e3: "OwnerName",
        65001: "SerialNumber",
        65002: "Lens",
        65024: "KDC_IFD",
        65100: "RawFile",
        65101: "Converter",
        65102: "WhiteBalance",
        65105: "Exposure",
        65106: "Shadows",
        65107: "Brightness",
        65108: "Contrast",
        65109: "Saturation",
        65110: "Sharpness",
        65111: "Smoothness",
        65112: "MoireFilter"
      },
      gps: {
        0: "GPSVersionID",
        1: "GPSLatitudeRef",
        2: "GPSLatitude",
        3: "GPSLongitudeRef",
        4: "GPSLongitude",
        5: "GPSAltitudeRef",
        6: "GPSAltitude",
        7: "GPSTimeStamp",
        8: "GPSSatellites",
        9: "GPSStatus",
        10: "GPSMeasureMode",
        11: "GPSDOP",
        12: "GPSSpeedRef",
        13: "GPSSpeed",
        14: "GPSTrackRef",
        15: "GPSTrack",
        16: "GPSImgDirectionRef",
        17: "GPSImgDirection",
        18: "GPSMapDatum",
        19: "GPSDestLatitudeRef",
        20: "GPSDestLatitude",
        21: "GPSDestLongitudeRef",
        22: "GPSDestLongitude",
        23: "GPSDestBearingRef",
        24: "GPSDestBearing",
        25: "GPSDestDistanceRef",
        26: "GPSDestDistance",
        27: "GPSProcessingMethod",
        28: "GPSAreaInformation",
        29: "GPSDateStamp",
        30: "GPSDifferential",
        31: "GPSHPositioningError"
      }
    };
  }
});

// node_modules/exif/lib/exif/index.js
var require_exif = __commonJS({
  "node_modules/exif/lib/exif/index.js"(exports, module2) {
    module2.exports = require_ExifImage();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageClickLogger
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_exif = __toESM(require_exif());
var VIEW_TYPE_IMAGE_CLICK = "image-click-view";
var ImageClickView = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
  }
  getViewType() {
    return VIEW_TYPE_IMAGE_CLICK;
  }
  getDisplayText() {
    return "Image Click Logger";
  }
  getIcon() {
    return "image";
  }
  async onOpen() {
    this.contentEl = this.containerEl.children[1].createDiv();
  }
  async onClose() {
  }
  renderMetadataComponent(metadata) {
    console.log("exif!", metadata);
    const container = document.createElement("div");
    const metadataContainer = document.createElement("div");
    metadataContainer.className = "metadata-container";
    for (const sectionName in metadata) {
      console.log(sectionName);
      const section = metadata[sectionName];
      const sectionDiv = document.createElement("div");
      sectionDiv.className = "metadata-section";
      const sectionTitle = document.createElement("h2");
      sectionTitle.textContent = sectionName;
      sectionDiv.appendChild(sectionTitle);
      const sectionTable = document.createElement("table");
      for (const key in section) {
        const value = section[key];
        const row = document.createElement("tr");
        const keyCell = document.createElement("td");
        keyCell.textContent = key;
        row.appendChild(keyCell);
        const valueCell = document.createElement("td");
        if (Buffer.isBuffer(value)) {
          valueCell.textContent = value.toString("hex");
        } else {
          valueCell.textContent = String(value);
        }
        row.appendChild(valueCell);
        sectionTable.appendChild(row);
      }
      sectionDiv.appendChild(sectionTable);
      metadataContainer.appendChild(sectionDiv);
    }
    container.appendChild(metadataContainer);
    console.log(container);
    return container;
  }
  remoteOpen(image, contentEl, activateView, cb) {
    console.log("remote open");
    (0, import_obsidian.requestUrl)({ url: image.src }).then((response) => response.arrayBuffer).then((buffer) => {
      try {
        console.log("calling callback");
        cb(buffer, contentEl, activateView);
      } catch (error) {
        console.error("Error:", error.message);
      }
    }).catch((error) => console.error("Request error:", error));
  }
  localOpen(contentEl, activateView, cb) {
    console.log("local open");
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      console.log("no file!");
    } else {
      console.log(this.app.vault);
      this.app.vault.readBinary(file).then((buffer) => {
        if (buffer instanceof ArrayBuffer) {
          try {
            console.log("calling callback");
            cb(buffer, contentEl, activateView);
          } catch (error) {
            console.error("Error:", error.message);
          }
        } else {
          console.error("Could not read blob as ArrayBuffer");
        }
      });
    }
  }
  parseMetadata(arrayBuffer, contentEl, activateView) {
    console.log("parse metadata");
    new import_exif.ExifImage({ image: Buffer.from(arrayBuffer) }, (error, exifData2) => {
      console.log("error: ", error);
      console.log("exif: ", exifData2);
      if (exifData2 === void 0) {
        contentEl.innerHTML = "";
        return;
      }
      console.log("exif: ", exifData2);
      const content = this.renderMetadataComponent(exifData2);
      activateView();
      console.log("painting content");
      console.log(content);
      contentEl.innerHTML = "";
      contentEl.appendChild(content);
    });
  }
  onImageClick(image, activateView) {
    if (image.src && image.src.startsWith("http")) {
      this.remoteOpen(image, this.contentEl, activateView, this.parseMetadata.bind(this));
    } else {
      this.localOpen(this.contentEl, activateView, this.parseMetadata.bind(this));
    }
  }
  update() {
    this.localOpen(this.contentEl, () => {
    }, this.parseMetadata.bind(this));
  }
};
var ImageClickLogger = class extends import_obsidian.Plugin {
  clickHandler(event) {
    console.log("got event!");
    const target = event.target;
    if (target.tagName.toLowerCase() === "img") {
      const img = target;
      console.log("event was an image!");
      console.log(img);
      this.handleImageClick(img);
    }
  }
  onload() {
    this.registerView(VIEW_TYPE_IMAGE_CLICK, (leaf) => new ImageClickView(leaf));
    this.registerMarkdownPostProcessor((el, ctx) => {
      const images = el.querySelectorAll("img");
      images.forEach((img) => {
        img.addEventListener("click", this.clickHandler.bind(this));
      });
    });
    this.registerEvent(this.app.workspace.on("layout-change", () => {
      this.app.workspace.iterateAllLeaves((leaf) => {
        var _a;
        if (((_a = leaf.getViewState()) == null ? void 0 : _a.type) === "image") {
          const images = leaf.view.containerEl.querySelectorAll("img");
          images.forEach((img) => {
            img.addEventListener("click", this.clickHandler.bind(this));
          });
          const imageClickView = this.app.workspace.getLeavesOfType(VIEW_TYPE_IMAGE_CLICK)[0];
          if (imageClickView) {
            const view = imageClickView.view;
            if (view instanceof ImageClickView) {
              view.update();
            }
          }
        }
      });
    }));
  }
  onunload() {
  }
  async activateView() {
    let { workspace } = this.app;
    let leaf = null;
    let leaves = workspace.getLeavesOfType(VIEW_TYPE_IMAGE_CLICK);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE_IMAGE_CLICK, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  handleImageClick(image) {
    console.log("handleImageClick");
    console.log(image);
    if (!image)
      return;
    const imageClickView = this.app.workspace.getLeavesOfType(VIEW_TYPE_IMAGE_CLICK)[0];
    if (imageClickView) {
      const view = imageClickView.view;
      if (view instanceof ImageClickView) {
        view.onImageClick(image, this.activateView.bind(this));
      }
    }
  }
};
